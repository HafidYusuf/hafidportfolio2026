<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Venn-scroll — white->light blue->solid blue</title>
<style>
  html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  body { background: #ffffff; }

  /* full-height scroll area so ScrollTrigger has room */
  .scroll-section {
    height: 220vh;                /* lots of scroll space */
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  svg {
    width: 90%;
    height: 420px;
    overflow: visible;
    display:block;
    position: absolute;
    top: 20%;
  }

  /* circle visual style */
  .venn-circle {
    fill: #ffffff;/* white single circles */
  }

  /* overlays are drawn after circles in DOM so they paint ON TOP where appropriate */
  .pair-fill { fill: #CEE1FF; /* light-blue for pair -> approx (0.5,0.739,1) */ opacity: 0; }
  .triple-fill { fill: #0062FF; /* solid blue for triple */ opacity: 0; }

  /* helpful guide text */
  .hint {
    position: fixed; left: 16px; top:16px; color:#333; font-size:14px;
    background: rgba(255,255,255,0.9); padding:8px 12px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.06);
  }
</style>
</head>
<body>

<div class="hint">Scroll to see the circles move — single = white, two-overlap = light blue, three-overlap = solid blue</div>

<section class="scroll-section">
  <svg id="venn" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg" >
    <defs></defs>

    <!-- circles (drawn first) -->
    <g id="circles">
        <!-- start positions (separated) -- GSAP will animate attr(cx,cy) -->
        <circle id="c1" class="venn-circle" cx="80" cy="0" r="140" />
        <circle id="c1-stroke" cx="80" cy="0" r="138" fill="none" stroke="blue" stroke-width="1" />
        <text id="c1-label" x="80" y="0" text-anchor="middle" dominant-baseline="middle" font-size="18" fill="black">Aesthetic</text>

        <circle id="c2" class="venn-circle" cx="400" cy="0" r="140" />
        <circle id="c2-stroke" cx="400" cy="0" r="138" fill="none" stroke="blue" stroke-width="1" />
        <text id="c2-label" x="400" y="0" text-anchor="middle" dominant-baseline="middle" font-size="18" fill="black">Interactivity</text>
        
        <circle id="c3" class="venn-circle" cx="720" cy="0" r="140" />
        <circle id="c3-stroke" cx="720" cy="0 " r="138" fill="none" stroke="blue" stroke-width="1" />
        <text id="c3-label" x="720" y="0" text-anchor="middle" dominant-baseline="middle" font-size="18" fill="black">Development</text>
    </g>

    <!-- overlap shapes (drawn ON TOP) -->
    <g id="overlaps">
      <path id="pair12" class="pair-fill"/>
      <path id="pair23" class="pair-fill"/>
      <path id="pair13" class="pair-fill"/>
      <path id="triple" class="triple-fill"/>
    </g>

    <g id="thelogo" transform="translate(383,38) scale(1.5)" fill="none" stroke="#ffffff" stroke-width="1">
        <path d="M2.66797 3.55561C2.66797 2.57377 3.46391 1.77783 4.44575 1.77783L8.89019 1.77783V8.00005C8.89019 8.98189 8.09425 9.77783 7.11241 9.77783H2.66797L2.66797 3.55561Z"/>
        <path d="M15.1094 15.9999C15.1094 15.0181 15.9053 14.2222 16.8872 14.2222L21.3316 14.2222V20.4444C21.3316 21.4262 20.5357 22.2222 19.5538 22.2222H15.1094L15.1094 15.9999Z"/>
        <path d="M21.335 8.00049C21.3347 8.98202 20.5391 9.77763 19.5576 9.77783H18.668L17.4951 9.78076C15.113 9.80505 15.1133 9.99987 15.1133 11.5552L15.1123 11.5542V12.4448C15.1121 13.4265 14.3167 14.2222 13.335 14.2222H12.4453C8.8909 14.2222 8.88965 14.2224 8.88965 17.7778V20.4448C8.88941 21.4265 8.09399 22.2222 7.1123 22.2222H2.66797V15.9995C2.6682 15.018 3.46376 14.2223 4.44531 14.2222H5.33496C8.88989 14.2222 8.88965 14.2222 8.88965 12.4448H8.89062V11.5552C8.89086 10.5737 9.68645 9.77804 10.668 9.77783H11.5576C15.112 9.77783 15.1133 9.7776 15.1133 6.22217V3.55518C15.1135 2.57355 15.9089 1.77783 16.8906 1.77783H21.335V8.00049Z"/>
    </g>
    <g id="thelogo-fill" transform="translate(383,38) scale(1.5)" opacity="0" fill="#ffffff">
        <path d="M2.66797 3.55561C2.66797 2.57377 3.46391 1.77783 4.44575 1.77783L8.89019 1.77783V8.00005C8.89019 8.98189 8.09425 9.77783 7.11241 9.77783H2.66797L2.66797 3.55561Z"/>
        <path d="M15.1094 15.9999C15.1094 15.0181 15.9053 14.2222 16.8872 14.2222L21.3316 14.2222V20.4444C21.3316 21.4262 20.5357 22.2222 19.5538 22.2222H15.1094L15.1094 15.9999Z"/>
        <path d="M21.335 8.00049C21.3347 8.98202 20.5391 9.77763 19.5576 9.77783H18.668L17.4951 9.78076C15.113 9.80505 15.1133 9.99987 15.1133 11.5552L15.1123 11.5542V12.4448C15.1121 13.4265 14.3167 14.2222 13.335 14.2222H12.4453C8.8909 14.2222 8.88965 14.2224 8.88965 17.7778V20.4448C8.88941 21.4265 8.09399 22.2222 7.1123 22.2222H2.66797V15.9995C2.6682 15.018 3.46376 14.2223 4.44531 14.2222H5.33496C8.88989 14.2222 8.88965 14.2222 8.88965 12.4448H8.89062V11.5552C8.89086 10.5737 9.68645 9.77804 10.668 9.77783H11.5576C15.112 9.77783 15.1133 9.7776 15.1133 6.22217V3.55518C15.1135 2.57355 15.9089 1.77783 16.8906 1.77783H21.335V8.00049Z"/>
    </g>

  </svg>
</section>

<!-- GSAP + ScrollTrigger CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

<script>
/* ========== Geometry helpers ========== */

/** return the two intersection points of two equal-radius circles (or null if none)
 *  cx0,cy0, cx1,cy1, r
 *  returns [{x,y},{x,y}] or null
 */
function intersectTwoEqualCircles(cx0, cy0, cx1, cy1, r) {
  const dx = cx1 - cx0, dy = cy1 - cy0;
  const d = Math.hypot(dx, dy);
  if (d === 0 || d >= 2*r) return null; // no intersection (or infinite)
  const a = d/2.0;                      // for equal radii
  const h = Math.sqrt(Math.max(0, r*r - a*a));
  const xm = cx0 + (a * dx / d);
  const ym = cy0 + (a * dy / d);
  const rx = -dy * (h / d);
  const ry = dx * (h / d);

  const p1 = { x: xm + rx, y: ym + ry };
  const p2 = { x: xm - rx, y: ym - ry };
  return [p1, p2];
}

/** arc sweep flag: choose arc direction for arc on circle centered at `c`
 *  from pStart -> pEnd (returns 0 or 1)
 *  We'll choose the smaller arc (large-arc-flag = 0) and pick sweep based on signed delta angle.
 */
function arcSweepFlag(circleCenter, pStart, pEnd) {
  const a1 = Math.atan2(pStart.y - circleCenter.y, pStart.x - circleCenter.x);
  const a2 = Math.atan2(pEnd.y - circleCenter.y, pEnd.x - circleCenter.x);
  let delta = a2 - a1;
  while (delta <= -Math.PI) delta += 2*Math.PI;
  while (delta > Math.PI) delta -= 2*Math.PI;
  // if delta positive, sweep=1 (ccw), otherwise 0
  return (delta > 0) ? 1 : 0;
}

/** build lens path (two arcs) between circleA and circleB (equal radii).
 *  Returns an SVG path d string, or empty string if no intersection.
 */
function lensPath(circleA, circleB, r) {
  const pts = intersectTwoEqualCircles(circleA.x, circleA.y, circleB.x, circleB.y, r);
  if (!pts) return "";
  const p1 = pts[0], p2 = pts[1];
  const sweep1 = arcSweepFlag(circleA, p1, p2);
  const sweep2 = arcSweepFlag(circleB, p2, p1);
  // Use small-arc (large-arc-flag = 0)
  return `M ${p1.x.toFixed(3)} ${p1.y.toFixed(3)} ` +
         `A ${r} ${r} 0 0 ${sweep1} ${p2.x.toFixed(3)} ${p2.y.toFixed(3)} ` +
         `A ${r} ${r} 0 0 ${sweep2} ${p1.x.toFixed(3)} ${p1.y.toFixed(3)} Z`;
}

/** triple intersection (curvy triangular area). 
 *  Returns d string or empty string if triple doesn't exist.
 */
function triplePath(c1, c2, c3, r) {
  // get intersection points (2 each), pick the one that lies closest to centroid
  const pts12 = intersectTwoEqualCircles(c1.x,c1.y,c2.x,c2.y,r);
  const pts23 = intersectTwoEqualCircles(c2.x,c2.y,c3.x,c3.y,r);
  const pts13 = intersectTwoEqualCircles(c1.x,c1.y,c3.x,c3.y,r);
  if (!pts12 || !pts23 || !pts13) return "";

  const centroid = {
    x: (c1.x + c2.x + c3.x)/3,
    y: (c1.y + c2.y + c3.y)/3
  };

  // choose the intersection point from each pair that is closest to centroid
  function choose(pts) {
    const d0 = Math.hypot(pts[0].x - centroid.x, pts[0].y - centroid.y);
    const d1 = Math.hypot(pts[1].x - centroid.x, pts[1].y - centroid.y);
    return d0 < d1 ? pts[0] : pts[1];
  }
  const p12 = choose(pts12);
  const p23 = choose(pts23);
  const p13 = choose(pts13);

  // order these three points around the centroid (clockwise)
  const arr = [
    {name:'12', p: p12},
    {name:'23', p: p23},
    {name:'13', p: p13}
  ];
  arr.sort((A,B) => {
    const aAng = Math.atan2(A.p.y - centroid.y, A.p.x - centroid.x);
    const bAng = Math.atan2(B.p.y - centroid.y, B.p.x - centroid.x);
    return aAng - bAng;
  });

  // for each segment between consecutive points pick which circle's arc contains both intersection points
  // mapping: segment between p12 and p23 -> common circle is c2, between p23 and p13 -> common circle c3, etc.
  // We'll compute common center for each pair by finding which circle's distance to both points is ~r.
  function commonCenterForTwoPoints(pa, pb) {
    const d1 = Math.abs(Math.hypot(pa.x - c1.x, pa.y - c1.y) - r) < 1e-6 &&
               Math.abs(Math.hypot(pb.x - c1.x, pb.y - c1.y) - r) < 1e-6 ? c1 : null;
    const d2 = Math.abs(Math.hypot(pa.x - c2.x, pa.y - c2.y) - r) < 1e-6 &&
               Math.abs(Math.hypot(pb.x - c2.x, pb.y - c2.y) - r) < 1e-6 ? c2 : null;
    const d3 = Math.abs(Math.hypot(pa.x - c3.x, pa.y - c3.y) - r) < 1e-6 &&
               Math.abs(Math.hypot(pb.x - c3.x, pb.y - c3.y) - r) < 1e-6 ? c3 : null;
    return d1 || d2 || d3;
  }

  // Build path by arcs: start at arr[0].p, arc on its common center to arr[1].p, arc on next center to arr[2].p, arc on next center back to arr[0].p
  const pA = arr[0].p, pB = arr[1].p, pC = arr[2].p;

  // find centers for each arc
  const centerAB = commonCenterForTwoPoints(pA,pB);
  const centerBC = commonCenterForTwoPoints(pB,pC);
  const centerCA = commonCenterForTwoPoints(pC,pA);

  if (!centerAB || !centerBC || !centerCA) return ""; // safety

  const sweepAB = arcSweepFlag(centerAB, pA, pB);
  const sweepBC = arcSweepFlag(centerBC, pB, pC);
  const sweepCA = arcSweepFlag(centerCA, pC, pA);

  // build curved triangular path
  const d =
    `M ${pA.x.toFixed(3)} ${pA.y.toFixed(3)} ` +
    `A ${r} ${r} 0 0 ${sweepAB} ${pB.x.toFixed(3)} ${pB.y.toFixed(3)} ` +
    `A ${r} ${r} 0 0 ${sweepBC} ${pC.x.toFixed(3)} ${pC.y.toFixed(3)} ` +
    `A ${r} ${r} 0 0 ${sweepCA} ${pA.x.toFixed(3)} ${pA.y.toFixed(3)} Z`;

  return d;
}

/* ========== setup & animation ========== */
gsap.registerPlugin(ScrollTrigger);

const c1el = document.getElementById('c1');
const c2el = document.getElementById('c2');
const c3el = document.getElementById('c3');

const pair12 = document.getElementById('pair12');
const pair23 = document.getElementById('pair23');
const pair13 = document.getElementById('pair13');
const triple = document.getElementById('triple');

const r = parseFloat(c1el.getAttribute('r'));

/** read current circle positions (as floats) */
function readPos(el) {
  return { x: parseFloat(el.getAttribute('cx')), y: parseFloat(el.getAttribute('cy')) };
}

/** compute & set overlap paths; also fade overlays in/out logically */
function updateOverlays() {
  const c1 = readPos(c1el);
  const c2 = readPos(c2el);
  const c3 = readPos(c3el);

  // pair lens paths
  const d12 = lensPath(c1,c2,r);
  const d23 = lensPath(c2,c3,r);
  const d13 = lensPath(c1,c3,r);

  // set path d and animate opacity based on existence (smooth)
  pair12.setAttribute('d', d12 || '');
  pair23.setAttribute('d', d23 || '');
  pair13.setAttribute('d', d13 || '');

  // triple region
  const dTriple = triplePath(c1,c2,c3,r);
  triple.setAttribute('d', dTriple || '');

  // opacities: smoothly show an overlay if its d is non-empty
  gsap.to(pair12, { duration: 0.15, attr: {}, opacity: d12 ? 1 : 0 });
  gsap.to(pair23, { duration: 0.15, attr: {}, opacity: d23 ? 1 : 0 });
  gsap.to(pair13, { duration: 0.15, attr: {}, opacity: d13 ? 1 : 0 });
  gsap.to(triple, { duration: 0.15, attr: {}, opacity: dTriple ? 1 : 0 });
}

/* Initial overlay (none intersecting) */
updateOverlays();

/* ===== GSAP Scroll animation =====
   - as user scrolls, circles move from separated -> overlapped arrangement
*/
const tl = gsap.timeline({
  scrollTrigger: {
    trigger: ".scroll-section",
    start: "top top",
    end: "+=1000",   // length of scroll-driven animation
    scrub: 0.6,
    pin: true,
  },
  onUpdate: updateOverlays
});

// prepare paths
gsap.utils.toArray("#thelogo path").forEach(path => {
  const length = path.getTotalLength();
  gsap.set(path, {
    strokeDasharray: length,
    strokeDashoffset: length
  });
});

// define final (overlapped) positions (equilateral-ish)
const final = {
  c1: { cx: 310, cy: 0 },
  c2: { cx: 490, cy: 0 },
  c3: { cx: 400, cy: 155 }
};

// animate the cx/cy attributes on each circle
tl.to("#c1, #c1-stroke", { duration: 1, attr: { cx: final.c1.cx, cy: final.c1.cy }, ease: "power2.inOut" }, 0);
tl.to("#c1-label", { duration: 1, attr: { x: final.c1.cx - 40, y: final.c1.cy }, ease: "power2.inOut" }, 0);
tl.to("#c2, #c2-stroke", { duration: 1, attr: { cx: final.c2.cx, cy: final.c2.cy }, ease: "power2.inOut" }, 0);
tl.to("#c2-label", { duration: 1, attr: { x: final.c2.cx + 40, y: final.c2.cy }, ease: "power2.inOut" }, 0);
tl.to("#c3, #c3-stroke", { duration: 1, attr: { cx: final.c3.cx, cy: final.c3.cy }, ease: "power2.inOut" }, 0);
tl.to("#c3-label", { duration: 1, attr: { x: final.c3.cx, y: final.c3.cy + 40 }, ease: "power2.inOut" }, 0);
tl.to("#thelogo path", { strokeDashoffset: 0, duration: 1, stagger: 0.3, ease: "power2.inOut" }, "step3");
tl.to("#thelogo-fill", { opacity: 1, duration: 0.5 }, "step3+=1.5");

// keep overlays recalculated while the timeline updates
tl.eventCallback("onUpdate", updateOverlays);

</script>
</body>
</html>
